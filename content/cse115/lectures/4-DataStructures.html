---
title: Data Structures
short_title: ds
next_content_short: files
previous_content_short: functions
---


[Monday - Using ArrayList including as input to their method (unknown number of unknown values!)]
[Wednesday - Using Map]
[Friday - For-each]


{#== Data Structures#}
{##}
{#Slides? (I don't have a lot of individual things. I have a group of things. This is my collection of video games.#}
{#I can perform acts on my things. I clean all my dishes. I don't say I clean plate1, plate2, plate3, spoon1, spoon2, etc.#}
{#I clean my collection of nameless dishes. I launder all my clothes. While I some plates with certain scratches that I#}
{#recognize, I don't name each one as we would with variables. I just have plates. Sometimes they do all have names but we#}
{#to do something to all of them anyway. This class has 32 named TAs and sometimes you want to ask all of them a question#}
{#on the question site to maximize the chance of a quick response.)#}
{##}
{#When we want to store multiple related values.#}
{##}
{#Don't know how many we want to store.#}
{##}
{#Even if we know, what if we need to store 10000 values? Declare 10000 variables all with different names?#}


== Import


<p>
    Before we start using data structures in java we will need to learn one more aspect of the language. The import
    statement. We add our import statements before the beginning of the class definition for our program. In the
    upcoming lesson we will add <code>import java.util.ArrayList;</code> to give us access to the <a
        href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a> class.
</p>
<p>
    There are many classes like ArrayList that are packaged with java, but must be added with an import statement to be
    used. Only classes
    in <a heref="https://docs.oracle.com/javase/7/docs/api/java/lang/package-summary.html">java.lang</a> are available
    by default as these classes have been determined to be so fundamental that every program should have immediate
    access to them. The rest of the classes must be imported to let the compiler know to load the
    additional classes. If a class is used without being imported the program will not run. For example if we attempt to
    use the ArrayList class without importing it first we will see the error <code>ArrayList cannot be resolved to a
    type</code>.
</p>


== Type Parameters

<p>
    When we crate a data structure in Java we must specify which type the data structure can store. This type must be a
    <a href="https://docs.oracle.com/javase/tutorial/java/concepts/class.html">class</a> and the data structure can only
    store objects of that class type. By java naming convention, if a type starts with a capital letter it is a class
    and if it starts with a lowercase letter it is a primitive. A primitive is a data type that only stores a value
    where an object can contain many values as well as methods. We have been using objects of type String throughout the
    course and we noticed that String starts with a capital S and we also have access to many methods by using the
    dot-operator on a String value.
</p>

<p>
    This sets up a big problem in that int, double, and boolean are all primitive types and therefor cannot be used as
    the type for data structures. This means we can never create a data structure that stores int, doubles, or boolean
    types. Luckily there is a very simple solution to this limitation by using wrapper classes.
</p>

<dl>
    <dt>Wrapper Class</dt>
    <dd>A class that can be used in place of a primitive type.</dd>
</dl>

<p>Instead of using the primitive types int, double, and boolean we will use the wrapper classes Integer, Double, and
    Boolean. These wrapper classes can be used <em>nearly</em> interchangeably with their primitive counterparts. Using
    these wrapper classes will allow us to store primitive values in data structures as well as give us access to a
    variety of methods that can be used in the same way as the String methods we've been using.
</p>

== ArrayList

<p>
    Armed with import statements and wrapper classes we are ready to use our first data structure, the ArrayList. An
    ArrayList is used to store multiple values of a provided type. The order of these values is preserved and their
    positions are indexed by integers starting at 0. This means the first value in an ArrayList is stored at index 0,
    the second at index 1, the third at index 2, and so on.
</p>
{#new keyword#}
{##}
{#Create a variable to store an ArrayList of a particular type.#}
{#Name the variable.#}
{#Create a new ArrayList of that type.#}
{#Store the new ArrayList in the variable.#}
{#-Do whatever we need to do with the ArrayList.#}
{##}
{#ArrayList#}

<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">Javadocs: ArrayList</a>

{#Must have a type. It's a collection of values of that type.#}
{##}
{#Elements each have an index. Access data by its index. Indexing starts at 0.#}
{#(side note, we can get a char from a String by index. String is an array of char)#}


<hr/>
<h4>new</h4>
<p>
    To create an ArrayList, we can't simply give it a value. We must use the new keyword as well as specify the type
    parameter. Here we create a new ArrayList of Integers and name it listOfIntegers.
</p>
<pre>
        ArrayList&lt;Integer&gt; listOfIntegers = new ArrayList&lt;Integer&gt;();
        System.out.println(listOfIntegers);
</pre>

<p>
    Output: <kbd>[]</kbd>
</p>

<p>
    When we print the list we will see that it is empty.
</p>

<hr/>
<h4>add</h4>
<p>
    The add method will add an element to the end of an ArrayList. Using our list from the previous example we'll add 50
    to the end of the list.
</p>
<pre>
        listOfIntegers.add(50);
        System.out.println(listOfIntegers);
</pre>

<p>
    Output: <kbd>[50]</kbd>
</p>

<hr/>
<h4>get</h4>
<p>
    We'll also use the get method which returns a value at a particular index. Indexing in lists range from 0 to the
    number of elements minus 1.
</p>
<pre>
        System.out.println(listOfIntegers.get(0));
</pre>

<p>
    Output: <kbd>50</kbd>
</p>

<hr/>
<h4>size</h4>
<p>
    The size method returns the number of elements in the ArrayList.
</p>
<pre>
        System.out.println(listOfIntegers.size());
</pre>

<p>
    Output: <kbd>1</kbd>
</p>

<hr/>
<h4>contains</h4>
<p>
    Similar to the contains method for Strings, ArrayList has a contains method that returns true only if the element is
    in the list.
</p>
<pre>
        System.out.println(listOfIntegers.contains(50));
        System.out.println(listOfIntegers.contains(70));
</pre>

<p>
    Output: </p>
<kbd>true<br/>false</kbd>

<hr/>
<h4>Full Example</h4>


<pre>
import java.util.ArrayList;

public class DataStructureExample {

    static ArrayList&lt;Integer&gt; getList(){
        ArrayList&lt;Integer&gt; listOfIntegers = new ArrayList&lt;Integer&gt;();
        listOfIntegers.add(50);
        listOfIntegers.add(20);
        return listOfIntegers;
    }
    
    public static void main(String[] args){
        ArrayList&lt;Integer&gt; returnedList = getList();
        System.out.println(returnedList);
        System.out.println(returnedList.get(0));
        System.out.println(returnedList.get(1));
        System.out.println(returnedList.size());
    }
}
</pre>

<p>
    Output:
</p>
<kbd>[50, 20]<br/>50<br/>20<br/>2</kbd>

<p>
    This example shows everything we need to get started with ArrayList. Let's analyze this example one step at a time.
</p>
<br/>
<p>Breakdown:</p>
<ol>
    <li><code>import java.util.ArrayList;</code> Let the compiler know that we will use the ArrayList class</li>
    <li><code>ArrayList&lt;Integer&gt; returnedList = getList();</code> Control starts with the main method. In the
        first line we create a variable that can store an ArrayList of Integers, name it returnedList, and set it equal
        to the return value of the getList() method which has a return type of ArrayList&lt;Integer&gt;.
    </li>
    <li><code>getList()</code> To set the value of returnedList, the call to getList() must be resolved. There are not
        arguments or parameters to handle so control moves directly to the first line of the method.
    </li>
    <li><code>ArrayList&lt;Integer&gt; listOfIntegers = ...</code> Similar to the first line
        of main, we create a variable that can store an ArrayList of Integers and name it listOfIntegers.
    </li>
    <li><code>... = new ArrayList&lt;Integer&gt;();</code> Create a new instance of an ArrayList of Integers using the
        new keyword.
    </li>
    <li><code>listOfIntegers.add(50);</code> Add the value 50 to the end of the ArrayList. Since 50 is the first element
        added to the list it is placed at index 0.
    </li>
    <li><code>return listOfIntegers;</code> Return the ArrayList back to the main method.</li>
    <li><code>ArrayList&lt;Integer&gt; returnedList = getList();</code> Return to the main method and set the value of
        returnedList equal to the list returned from getList()
    </li>
    <li><code>System.out.println(returnedList);</code> Print the contents of returnedList in order "[50, 20]"</li>
    <li><code>System.out.println(returnedList.get(0));</code> Print the value at index 0 in the list "50"</li>
    <li><code>System.out.println(returnedList.get(1));</code> Print the value at index 1 in the list "20"
    </li>
    <li><code>System.out.println(returnedList.size());</code> Print the number of elements in the list "2"
    </li>
    <li><code>}</code> The end of the main method is reached and the program ends.
    </li>
</ol>


== HashMap


<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">Javadocs: HashMap</a>

<p>
    Java's HashMap is similar to the ArrayList, except instead of indexing its values by sequential integers starting at
    0 the values are indexed by any type chosen by the programmer with no meaningful ordering. Thus when we store a
    value in a HashMap we must also provide an index value known as a key. We then call an element in a HashMap a
    key-value pair.
</p>

<p>
    As with ArrayList, we will need to import the HashMap class with <code>import java.util.HashMap;</code> before it
    can be used or we will see this error <code>HashMap cannot be resolved to a type</code>.
</p>

<hr/>
<h4>new</h4>
<p>
    Just like an ArrayList, we must use the new keyword to create a new instance of a HashMap. Since a HashMap need a
    type for its keys as well as it's values we must provide 2 types when creating a HashMap. The first type will
    specify the type for the keys and the second will determine the type of the values.
</p>
<pre>
        HashMap&lt;String, Integer&gt; mapOfStringsToDoubles = new HashMap&lt;String, Integer&gt;();
        System.out.println(mapOfStringsToDoubles);
</pre>

<p>
    Output: <kbd>{}</kbd>
</p>

<p>
    Here we have created a HashMap that maps String keys to Integer values and stored it in a variable named
    mapOfStringsToDoubles. When we print the map we see that it is empty. Let's add key-value pairs into the map using
    the put method.
</p>

<hr/>
<h4>put</h4>
<p>
    To insert key-value pairs into a HashMap we will call its put method. The put method takes 2 arguments. The first
    argument is the key and the second is the value to be stored. The types of these arguments must match the types of
    the HashMap.
</p>
<pre>
        mapOfStringsToDoubles.put("watch", 850);
        mapOfStringsToDoubles.put("luggage", 1099);
        mapOfStringsToDoubles.put("home theatre", 2100);
        System.out.println(mapOfStringsToDoubles);
</pre>

<p>
    Output: <kbd>{home theatre=2100, watch=850, luggage=1099}</kbd>
</p>

<p>
    Here we add 3 key-value pairs into the map print the map. Notice that when the map is printed the order is different
    that the order in which the values were inserted. Unlike ArrayLists, HashMaps do not store data in any meaningful
    order. We will get the values by providing their keys.
</p>


<hr/>
<h4>get</h4>
<p>
    To access the values in a HashMap we will call the get method with the key for the value as an argument.
</p>
<pre>
        int luggagePrice = mapOfStringsToDoubles.get("luggage");
        System.out.println(luggagePrice);
        System.out.println(mapOfStringsToDoubles.get("home theatre"));
</pre>

<p>
    Output: </p>
<kbd>1099<br/>2100</kbd>


<p>
    This allows us to access any of the stored data by providing the corresponding keys. In this case we want to store
    the prices of a variety of items. We don't want to memorize each price, but we do remember the items themselves.
    This makes it appropriate to store the prices as values and the item names as keys.
</p>

<p>
    Note: since the values are stored by their keys, a key can only appear in a map at most once. For example if we
    could put another home theatre into the map with a different price, which price would be returned when we call
    get("home theatre")?
</p>

<hr/>
<h4>size</h4>
<p>
    We can also get the number of key-value pairs stored in a HashMap we use its size method.
</p>
<pre>
        int numberOfEntries = mapOfStringsToDoubles.size();
        System.out.println(numberOfEntries);
</pre>

<p>
    Output: <kbd>3</kbd>
</p>

<p>
    Since we put 3 key-value pairs in this HashMap it will return 3 as its size.
</p>


<hr/>
<p>
    Putting the entire example together we have this program.
</p>

<pre>
import java.util.HashMap;

public class HashMapExample {

    static void example(){
        HashMap&lt;String, Integer&gt; mapOfStringsToDoubles = new HashMap&lt;String, Integer&gt;();
        System.out.println(mapOfStringsToDoubles);

        mapOfStringsToDoubles.put("watch", 850);
        mapOfStringsToDoubles.put("luggage", 1099);
        mapOfStringsToDoubles.put("home theatre", 2100);
        System.out.println(mapOfStringsToDoubles);

        int luggagePrice = mapOfStringsToDoubles.get("luggage");
        System.out.println(luggagePrice);
        System.out.println(mapOfStringsToDoubles.get("home theatre"));

        int numberOfEntries = mapOfStringsToDoubles.size();
        System.out.println(numberOfEntries);
    }

    public static void main(String[] args){
        example();
    }
}
</pre>

<p>
    Output: </p>
<kbd>{}<br/>{home theatre=2100, watch=850, luggage=1099}<br/>1099<br/>2100<br/>3</kbd>


{#== Iteration and the For-Each Loop#}
{##}
{##}
{##}
{#for(int i=0; i< ds.size(); i++);#}
{#for(int i=0; i< aString.length(); i++);#}
{##}
{#Print all elements in the ArrayList.#}
{##}
{#Add all these ints.#}
{##}
{#But wait, how can we iterate over all the elements of a HashMap? Visiting all the ints from 0 to size-1 doesn't do #}
{#us any good when the values are indexed by keys that don't follow this convention.#}
{##}
{#keySet()#}
{#values()#}
{##}
{#These return an abstract data structure called a Collection. #}
{#If we use these in for-each loops we treat these like ArrayLists.#}


{#== Databases#}
{##}
{#SQL? Too ambitious for transition 1?#}