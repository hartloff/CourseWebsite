---
title: GUI
short_title: gui
next_content_short: oo
previous_content_short: json
---

[This will get big. Might be split into 2 or more lessons]
[update: will it? There are tougher concepts earlier in the course and we're not going very deep into GUIs]

[Monday - Basic JFrame with labels n' shit (images)]
[Wednesday - Let's add buttons with action listeners! (drop down [combo box], radio buttons, text field)]
[Friday - Layouts]


== GUI

<p>
    So far everything we've done has lived in the command line. Whenever we wanted to output something to the users of
    our software we have been using <code>System.out.println</code> to display text to the console, and inputs needed to
    be made in code or through other files. In this section we will build GUIs (Graphical User Interfaces) to interact
    with our users more intuitively.
</p>


== JFrame

<p>
    It all starts with a JFrame. We will use javas built-in swing components to build GUIs. The base component in this
    library is the JFrame which creates a window for our applications.
</p>

<pre><code class="java">
import javax.swing.*;

public class Example{

    public static void runGUI(){
        JFrame frame = new JFrame("First GUI");
        frame.setSize(600, 400);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }


    public static void main(String[] args){
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                runGUI();
            }
        });
    }

}
</code></pre>

<p>
    Our first JFrame isn't very interesting, but this example shows the important aspects of setting up a GUI. First,
    we'll notice that the main method calls <code>SwingUtilities.invokeLater</code> on a new instance of the Runnable
    class. We Override this classes run method with a call to a method that initializes our GUI using syntax similar
    custom sorting using the Comparator class. This will run our GUI on a separate thread allowing us to continue our
    program while the GUI interacts with the user separately. This is called multi-threading and is a topic beyond the
    scope of this class so we will this conversation for a later course.
</p>

<p>
    Now let's look at the <code>runGUI</code> method that sets up the GUI itself. First, we need a JFrame so we create
    one using one of the JFrame's constructors. We call that constructor that takes a String as input which will be the
    title of the frame. This text will display in the title bar of the created window. Next, we set the size of the
    window in terms of pixels (600 pixels wide and 400 pixels for the height). Next we define what should happen when
    the window is closed. In this example we want our program to end so we'll set the close operation to exit. The final
    step is to actually display the GUI by setting its visibility to true. After all these steps we will have a GUI in
    the form of a JFrame with no components. In the rest of this section we will see a variety of components we can add
    to this frame to achieve the desired look and feel of our programs.
</p>

== Output Components

<p>
    We will not add components to our JFrame directely, but instead to its content pane which we'll access through its
    getter method <code>getContentPane()</code>. Once we have the content pane we can start adding components.
</p>

<pre><code class="java">
    frame.getContentPane().add(new JLabel("First Label"));
</code></pre>

<p>
    The first component we're adding is a JLabel. This JLabel provides a way to display text to our GUI by provided the
    String to be displayed in its constructor call. Here we are adding a new JLabel with the text "First Label" to the
    JFrame's content pane.
</p>

<p>
    We can also add images to our GUI by adding an ImageIcon to our JLabel:
</p>

<pre><code class="java">
    ImageIcon image = new ImageIcon("path/to/image");
    frame.getContentPane().add(new JLabel(image));
</code></pre>

<p>
    Here we create a new ImageIcon by providing the location of an image file, then adding a new JLabel to the content
    pane while providing the image in the constructor of the JLabel.
</p>

<p>
    We can also add images from the Internet by providing a url. Since reading the url can throw an exception we must
    use a try/catch block to get the image.
</p>

<pre><code class="java">
    ImageIcon image = null;
        try{
            URL url = new URL("http://www.buffalo.edu/UBT/UBT-archives/volume25number1/images/sports01.jpg");
            image = new ImageIcon(url);
        }catch(MalformedURLException e){
            e.printStackTrace();
        }

    frame.getContentPane().add(new JLabel(image));
</code></pre>

<p>
    In this example we download a jpg image from the Internet and display it on our GUI.
</p>

<hr/>

<h4>JPanel</h4>

<p>
    In the previous examples we added GUI components directly to the content pane of our JFrame which works, but can
    become difficult to maintain as our GUIs grow in complexity. For this reason we will add components to a JPanel,
    then add the JPanel to the JFrame's content pane. We will add components to a JPanel in a very similar way to adding
    them to a JFrame.
</p>

<pre><code class="java">
    JPanel panel = new JPanel();
    panel.add(new JLabel("First Label"));
    panel.add(new JLabel("Another Label"));
    frame.getContentPane().add(panel);
</code></pre>

<p>
    Here we create a new JPanel, add 2 new JLabels to it, then add the JPanel to our JFrame's content pane. This will
    display both labels on the GUI from left-to-right in the order they were added (This is the default behaviour of
    JPanel).
</p>

<hr/>

<h4>BorderLayout</h4>

<p>
    What if we want more control over the location of each element added to our GUI? For this, there are several
    different Layout Managers that can be used. We will only explore one of these, BorderLayout, which is the default
    layout for a JFrame. Alternatively the left-to-right behaviour of a JPanel is called FlowLayout. FlowLayout will
    automatically place the elements left-to-right as they are added, but with BorderLayout we must specify where each
    component should be displayed as either NORTH (top), SOUTH (bottom), EAST (right), WEST (left), or CENTER (default
    location).
</p>


<pre><code class="java">
    JPanel northPanel = new JPanel();
    northPanel.add(new JLabel("north"));
    frame.getContentPane().add(northPanel, BorderLayout.NORTH);

    JPanel southPanel = new JPanel();
    southPanel.add(new JLabel("south"));
    frame.getContentPane().add(southPanel, BorderLayout.SOUTH);

    JPanel eastPanel = new JPanel();
    eastPanel.add(new JLabel("east"));
    frame.getContentPane().add(eastPanel, BorderLayout.EAST);

    JPanel westPanel = new JPanel();
    westPanel.add(new JLabel("west"));
    frame.getContentPane().add(westPanel, BorderLayout.WEST);

    JPanel centerPanel = new JPanel();
    centerPanel.add(new JLabel("center"));
    frame.getContentPane().add(centerPanel, BorderLayout.CENTER);
</code></pre>

<p>
    When we add components to the JFrame using the BorderLayout we will specify its location using the BorderLayout
    constants (ie. BorderLayout.NORTH) as a second argument to the add method. In this example we add a different panel
    to each of the 5 areas of the GUI. If we add another element without providing a location it will be placed in the
    center of the GUI.
</p>

<p>
    CAUTION: Only one element can be placed in each of these 5 areas. Adding a second element to an area will overwrite
    the first component.
</p>

{#Panels and graphics?#}

{#== Input Components#}
{##}
{#<p>#}
{#</p>#}

{#Buttons#}
{#Action listeners#}

{#    JButton button = new JButton("Submit");#}
{#    button.addActionListener(new ActionListener(){#}
{#        @Override#}
{#        public void actionPerformed(ActionEvent e){#}
{#            makeGuess();#}
{#        }#}
{#    });#}


{#TextField#}
{#-getting it's text#}
{#inputText.setColumns(5);#}
{#Key Listeners#}

{#    inputText.addKeyListener(new KeyListener(){#}
{#        @Override#}
{#        public void keyTyped(KeyEvent e){#}
{##}
{#        }#}
{##}
{#        @Override#}
{#        public void keyPressed(KeyEvent e){#}
{#            if(e.getKeyCode() == KeyEvent.VK_ENTER){#}
{#                makeGuess();#}
{#            }#}
{#        }#}
{##}
{#        @Override#}
{#        public void keyReleased(KeyEvent e){#}
{##}
{#        }#}
{#    });#}


{#JLabel#}
{#-Setting the text/image#}

{#ComboBox with any type#}
{#-Calls toString for the display text#}
{#-Selects objects of the type used#}
{#-array (or vector aparently)#}
{#dropDown.getSelectedItem()#}


{#== Making a Web#}
{##}
{#GUI's that connect to API's and each other.#}
{##}
